---
layout: post
title: Normal Mixture
author: "Tobias Madsen"
tags: [example]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.path = "figs/normalMixture/")
knitr::opts_knit$set(base.url = '/dgRaph/')
```

<!--
Build post
setwd("../gh-pages-dgRaph/")
library(knitr)
render_jekyll()
knit(input = "../gh-pages-dgRaph/knitr//normalMixture.Rmd", output = "../gh-pages-dgRaph/_posts/2015-06-11-Normal-Mixture.md")
setwd("../dgRaph/")
-->

### When will I use a mixture of Normals?
So, you have misplaced your sample labels and a histogram of your data looks like this:

```{r setupPackages, cache = FALSE, echo=FALSE, cache=FALSE}
library(ggplot2)
library(dgRaph)
```

```{r plotMixture, cache = FALSE, warning=FALSE, echo=FALSE, fig.cap="center"}
set.seed(2)
data <- data.frame(x = c(rnorm(600, 10, 2.7), rnorm(300, 20, 2.7)))
data <- data[sample.int(900),,drop=F]
ggplot(data, aes(x = x)) + geom_histogram(binwidth = 0.5) + theme_bw() +
  theme(panel.border = element_blank(), axis.ticks = element_blank()) + ylab("Count") + xlab("Size") + ggtitle("Cat or Tiger?")
```

```{r headData}
head(data)
```

Now you wonder: Which measurements were from the siberian tigers you encountered on your adventures in the far east, and which measurements were from domestic cats at you grandma's?

Modelling this as a mixture of normals, we will be able to answer questions such as: How big are cats and tigers? How many were there of each? Which observations where tigers whichs where cats?

And by the way the data is just simulated using
```{r simulate data}
set.seed(2)
data <- data.frame(x = c(rnorm(600, 10, 2.7), rnorm(300, 20, 2.7)))
data <- data[sample.int(900),,drop=F]
```

### Building a Model


Being a bit more formal: From now on we will call the status of either cat or tiger a class-label. We do not observe the the class label, instead we observe the size. The size has a different distribution for each class. A natural model will be.

$$
H \sim Bernoulli(p) \\\\
X \mid H = 0 \sim \mathcal{N}(\mu\_0, \sigma\_0^2) \\\\
X \mid H = 1 \sim \mathcal{N}(\mu\_1, \sigma\_1^2)
$$

So we imagine that observations are generated by the following process: Flip a (biased) coin to decide which class the observation comes from, then draw from a normal distribution where the mean and variance depends on the class.

![center](/dgRaph/figs/shared/mixture_fac.svg)

To build this model in `dgRaph` we first need to decide the variable dimensions. The first variable `H` has dimension 2, from the two classes. The second variable `X` is continuous, so we will have to discretize it, lets say we decide to discretize it into 100 bins. 

```{r varDim}
varDim <- c(2, 100)
```

Second we need some factors(or really factor potentials). We will need a prior for `H`, tells us what is the proportion of samples from each class. To this end we can use a `multinomialPotential`. We also need the two normal distribution, that is conditional distributions given `H`, here we can use `normalPotential`. 

```{r facPot}
facPot <- list(multinomialPotential(dim = c(1, 2)),
               normalPotential(dim = c(2, 100)))
```

The last (strictly necessary) element is a description of the factor graph structure: Which variables are neighbors to which factors? So the prior is the neighbor of `H` the first variable, so it's neighbors is `c(1)`. The normal distribution potentials has both `H` and `X` as neighbors, alas both first and second variable, the rule is that the first neighbor is the variable we condition on, `H`, the second neighbor is the variable which conditional distribution the potential desribe, `X`, so the neighbors are `c(1,2)`. I repeat *First neighbor is the variable we condition on, second neighbor is the variable which conditional distribution we describe*.

```{r facNbs}
facNbs <- list(c(1),
               c(1,2))
```

We can now build the model

```{r mixDfg, warning=FALSE, message=FALSE, fig.cap="center"}
mixDfg <- dfg(varDim = varDim, facPot = facPot, facNbs = facNbs, varNames = c("H", "X"), facNames = c("Prior H", "X | H"))
plot(mixDfg)
```


### Training

We have build the model, but have not yet estimated the parameters $p, \mu\_0, \mu\_1, \sigma\_0^2, \sigma\_1^2$.
This is done using the `train` function. But first we have to create a dataset in the format that the `dgRaph` functions expect. That is discrete data and a column for each variable even the hidden variables. If a variable is unobserved we just supply `NA`.

```{r discretize, warning=FALSE}
library(dplyr)
data_discrete <- data %>%
  mutate(H = NA) %>%
  mutate(X = as.integer(cut(x, breaks = seq(0,30,length.out = 101), labels = c(1:100)))) %>%
  select(H, X)
head(data_discrete)
```

To get some meaningful output we also have to register a training function

```{r optimFun}
optimFun <- list(mixNorm = normOptimize(range = c(0, 30)))
```

```{r train, fig.cap="center"}
mixDfg <- train(data_discrete, mixDfg, optim = c("row", "mixNorm"), optimFun = optimFun, iter.max = 500, verbose = T)
```

### Inference

Let's have a look at the distribution. Firstly as we could already see from training, the prior assigns 1/3 and 2/3 of weight to each class. To see the distribution of size with-in the two classes, we can use the `potentials` functions, which returns a list of potentials. We will have a closer look at the second potential.

```{r potentials, fig.keep='none'}
pot <- potentials(mixDfg)[[2]]
library(reshape2)
pot_df <- melt(pot)
pot_df$size <- seq(0, 30, length.out = 101)[pot_df$Var2]
pot_df$Var1 <- as.factor(pot_df$Var1)
ggplot(pot_df, aes(x = size, y = value, colour = as.factor(Var1))) + geom_line()
```

```{r potentialsPlot, echo=FALSE, fig.cap="center"}
ggplot(pot_df, aes(x = size, y = value, colour = as.factor(Var1))) + geom_line() + theme_bw() + 
  theme(panel.border = element_blank(), axis.ticks = element_blank()) + ylab("~ Probability") + xlab("Size")
```

Finally lets classify our observations. We can do this using the `mps` function(most probable state). This gives us a dataframe where the `NA` has been replaced by the most probable state.

```{r mps}
mixMps <- mps(data = data_discrete, dfg = mixDfg)
head(mixMps, 10)
```

### Code

Download the full example [here]({{ site.baseurl}}/downloads/normalMixture.R).

### Beyond

It is easy to extend to more than just two classes. We also plan to extend from normal distributions to other classes, but at the moment we only support normal and beta distributions. Finally a user can supply his own optimization functions, we will cover that in another example. Stay tuned :)
